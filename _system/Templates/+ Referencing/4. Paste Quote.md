<%*
// Cite Quote Notes
// Configuration
const QUOTES_FOLDER = "Synthesis/Quotes";
const description = "into active file at cursor location ";

// Improved function to get metadata from file with better YAML parsing
async function getMetadata(file) {
    const content = await app.vault.read(file);
    const parts = content.split('---');
    if (parts.length < 2) return null;
    
    const frontmatter = parts[1];
    const metadata = {};
    let currentKey = null;
    let inList = false;
    let listValues = [];
    
    const lines = frontmatter.trim().split('\n');
    for (const line of lines) {
        // Check for list item
        if (line.trim().startsWith('- ')) {
            if (currentKey && inList) {
                // Continue adding to the existing list
                listValues.push(line.trim().substring(2));
            }
            continue;
        }
        
        // Check for key-value pair
        const colonIndex = line.indexOf(':');
        if (colonIndex > 0) {
            // If we were building a list, finalize it
            if (inList && currentKey) {
                metadata[currentKey] = listValues;
                inList = false;
                listValues = [];
            }
            
            // Extract new key and value
            currentKey = line.substring(0, colonIndex).trim();
            const value = line.substring(colonIndex + 1).trim();
            
            // Check if this is the start of a list (empty value after colon)
            if (!value) {
                inList = true;
                listValues = [];
            } else {
                metadata[currentKey] = value;
                inList = false;
            }
        }
    }
    
    // Handle any remaining list
    if (inList && currentKey) {
        metadata[currentKey] = listValues;
    }
    
    return metadata;
}

// Format author string for display
function formatAuthorDisplay(authorData) {
    if (!authorData) return "Unknown";
    
    if (Array.isArray(authorData)) {
        // Handle author array
        return authorData.map(author => {
            // Extract name from wiki link format "[[path|Name]]" or "[[path]]"
            const match = author.match(/\[\[.*?\|(.*?)\]\]/) || author.match(/\[\[(.*?)\]\]/);
            return match ? match[1].replace(/"/g, '') : author.replace(/"/g, '');
        }).join(", ");
    } else {
        // Handle single author string
        const match = authorData.match(/\[\[.*?\|(.*?)\]\]/) || authorData.match(/\[\[(.*?)\]\]/);
        return match ? match[1].replace(/"/g, '') : authorData.replace(/"/g, '');
    }
}

// Function to format source for display
function formatSourceDisplay(sourceData) {
    if (!sourceData) return "Unknown Source";
    
    try {
        // Extra safety with try/catch
        // Extract name from wiki link format "[[path|Name]]" or "[[path]]"
        // For path format like "[[Books/Book Title]]", extract just "Book Title"
        const match = sourceData.match(/\[\[.*?\|(.*?)\]\]/) || sourceData.match(/\[\[(.*?)\]\]/);
        if (match) {
            const path = match[1].replace(/"/g, '');
            // Get the last part of the path (after the last /)
            const parts = path.split('/');
            return parts[parts.length - 1];
        }
        return sourceData.replace(/"/g, '');
    } catch (error) {
        console.error("Error in formatSourceDisplay:", error, sourceData);
        return "Unknown Source";
    }
}

// Function to get all subfolders in the Quotes folder
async function getQuoteSubfolders() {
    const quotesFolder = app.vault.getAbstractFileByPath(QUOTES_FOLDER);
    if (!quotesFolder || !(quotesFolder instanceof tp.obsidian.TFolder)) {
        throw new Error("Quotes folder not found");
    }
    return quotesFolder.children.filter(child => child instanceof tp.obsidian.TFolder);
}

// Function to get all quote files in a specific subfolder
async function getQuoteFiles(subfolder) {
    return subfolder.children.filter(file => file instanceof tp.obsidian.TFile && file.extension === "md");
}

// MODIFIED: Function to format quote for menu display with option to hide source
function formatQuoteForMenu(content, author, source, hideSource = false) {
    const formattedAuthor = formatAuthorDisplay(author);
    if (hideSource) {
        return `${content}\nAuthor: ${formattedAuthor}`;
    } else {
        return `${content}\nAuthor: ${formattedAuthor}\nSource: ${formatSourceDisplay(source)}`;
    }
}

// Function to clean source name for wiki link
function cleanSourceForLink(source) {
    // Remove quotes, brackets, and trim whitespace
    return source.replace(/["\[\]]/g, '').trim();
}

// Function to extract a title from a source path
function getSourceTitle(source) {
    // Extract name from wiki link format "[[path|Name]]" or "[[path]]"
    const match = source.match(/\[\[.*?\|(.*?)\]\]/) || source.match(/\[\[(.*?)\]\]/);
    if (match) {
        const path = match[1].replace(/"/g, '');
        // Get the last part of the path (after the last /)
        const parts = path.split('/');
        return parts[parts.length - 1];
    }
    return source.replace(/"/g, '');
}

// Updated function to format quote for insertion with conditional source link for KOI items
function formatQuoteForInsertion(content, source, quoteFile, isKOI = false, metadata = null) {
    // For KOI items, use author_name and channel_name
    if (isKOI) {
        const quoteFilePath = quoteFile.path;
        const authorName = metadata?.author_name || "Unknown";
        const channelName = metadata?.channel_name || "Unknown channel";
        return `${content} ([[${quoteFilePath}|${authorName} in ${channelName}]])`;
    } 
    // For non-KOI items, include both source and quote file links
    else {
        const cleanSource = cleanSourceForLink(source);
        const sourceTitle = getSourceTitle(source);
        const quoteFilePath = quoteFile.path;
        
        return `${content} ([[${cleanSource}|${sourceTitle}]], [[${quoteFilePath}|see quote]])`;
    }
}

// Function to get all quotes across all subfolders
async function getAllQuotes() {
    const subfolders = await getQuoteSubfolders();
    const allQuotes = [];
    
    for (const subfolder of subfolders) {
        const quoteFiles = await getQuoteFiles(subfolder);
        for (const file of quoteFiles) {
            try {
                const content = await getFullQuoteContent(file);
                const metadata = await getMetadata(file);
                allQuotes.push({
                    file: file,
                    content: content,
                    author: metadata?.author || 'Unknown Author',
                    source: metadata?.source || 'Unknown Source',
                    author_name: metadata?.author_name || '',
                    channel_name: metadata?.channel_name || '',
                    class: metadata?.class || '',
                    category: metadata?.category || '',
                    ctime: file.stat?.ctime || 0 // Add creation timestamp
                });
            } catch (error) {
                console.error(`Error processing file ${file.path}:`, error);
            }
        }
    }
    
    return allQuotes;
}

// Function to get KOI quotes (class: Quotes, category: KOI), sorted by creation time
async function getKOIQuotes() {
    const allQuotes = await getAllQuotes();
    
    // Filter for quotes with class=Quotes and category=KOI
    const koiQuotes = allQuotes.filter(quote => 
        quote.class === 'Quotes' && quote.category === 'KOI'
    );
    
    // Sort by creation time, newest first
    return koiQuotes.sort((a, b) => b.ctime - a.ctime);
}

// NEW: Function to get Notes quotes (class: Quotes, category: Notes)
async function getNotesQuotes() {
    const allQuotes = await getAllQuotes();
    
    // Filter for quotes with class=Quotes and category=Notes
    const notesQuotes = allQuotes.filter(quote => 
        quote.class === 'Quotes' && quote.category === 'Notes'
    );
    
    // Sort by creation time, newest first
    return notesQuotes.sort((a, b) => b.ctime - a.ctime);
}

// NEW: Function to get all categories (excluding KOI and Notes)
async function getAllCategories() {
    const allQuotes = await getAllQuotes();
    const categorySet = new Set();
    
    // Filter quotes with class=Quotes and exclude KOI and Notes categories
    allQuotes
        .filter(quote => 
            quote.class === 'Quotes' && 
            quote.category !== 'KOI' && 
            quote.category !== 'Notes'
        )
        .forEach(quote => {
            if (quote.category) categorySet.add(quote.category);
        });
    
    return Array.from(categorySet).sort();
}

// NEW: Function to get quotes by specific category
async function getQuotesByCategory(category) {
    const allQuotes = await getAllQuotes();
    
    // Filter for quotes with the specified category
    const categoryQuotes = allQuotes.filter(quote => 
        quote.class === 'Quotes' && quote.category === category
    );
    
    // Sort by creation time, newest first
    return categoryQuotes.sort((a, b) => b.ctime - a.ctime);
}

// Function to get all unique sources, excluding KOI quotes
async function getAllSources() {
    const allQuotes = await getAllQuotes();
    const sourceSet = new Set();
    
    // Filter out KOI quotes before collecting sources
    allQuotes
        .filter(quote => !(quote.class === 'Quotes' && quote.category === 'KOI'))
        .forEach(quote => {
            try {
                const formattedSource = formatSourceDisplay(quote.source);
                if (formattedSource) sourceSet.add(formattedSource);
            } catch (error) {
                console.error("Error formatting source:", error, quote.source);
            }
        });
    
    return Array.from(sourceSet).sort();
}

// Function to get all unique authors
async function getAllAuthors() {
    const allQuotes = await getAllQuotes();
    const authorSet = new Set();
    
    allQuotes.forEach(quote => {
        if (Array.isArray(quote.author)) {
            quote.author.forEach(author => {
                const formattedAuthor = formatAuthorDisplay(author);
                if (formattedAuthor) authorSet.add(formattedAuthor);
            });
        } else {
            const formattedAuthor = formatAuthorDisplay(quote.author);
            if (formattedAuthor) authorSet.add(formattedAuthor);
        }
    });
    
    return Array.from(authorSet).sort();
}

// Function to extract the full quote content from a file
async function getFullQuoteContent(file) {
    const content = await app.vault.read(file);
    const parts = content.split('---');
    if (parts.length >= 3) {
        return parts[2].trim();
    }
    return ''; // Return empty string if the expected format is not found
}

// Updated function to insert quote content
async function insertQuote(content, source, quoteFile, isKOI = false, metadata = null) {
    const editor = app.workspace.activeLeaf.view.editor;
    const cursor = editor.getCursor();
    
    // Insert the formatted quote content at cursor position
    const formattedQuote = formatQuoteForInsertion(content, source, quoteFile, isKOI, metadata);
    editor.replaceRange(formattedQuote, cursor);
    
    // Move cursor to the end of the inserted content
    const lines = formattedQuote.split('\n');
    editor.setCursor({line: cursor.line + lines.length - 1, ch: lines[lines.length - 1].length});
}

// Main function with navigation back to previous menu
async function selectAndInsertQuote() {
    try {
        // Start with the main menu
        await showMainMenu();
    } catch (error) {
        console.error("An error occurred:", error);
        new Notice(`Error: ${error.message}. Check the console for details.`);
    }
}

// UPDATED: Function to show the main menu with new options
async function showMainMenu() {
    // Get all sources (excluding KOI)
    const allSources = await getAllSources();
    
    // Create menu options combining special options and sources
    const menuOptions = [
        { name: "🔍 Search All Quotes", type: 'all' },
        { name: "🧑‍🎓 Search By Author", type: 'author' },
        { name: "🔭 Search KOI", type: 'koi' },
        { name: "📝 Search Notes", type: 'notes' }, // New option for Notes
        { name: "📚 Search Other Categories", type: 'categories' }, // New option for categories
        ...allSources.map(source => ({
            name: source,
            source: source,
            type: 'source'
        }))
    ];
    
    // Show combined menu
    const selection = await tp.system.suggester(
        item => item.name,
        menuOptions,
        false,
        "Select Quote Source"
    );
    
    if (!selection) return;
    
    if (selection.type === 'all') {
        // Handle all quotes search
        await showAllQuotesMenu();
    } else if (selection.type === 'author') {
        // Handle author search
        await showAuthorMenu();
    } else if (selection.type === 'koi') {
        // Handle KOI quotes search
        await showKOIMenu();
    } else if (selection.type === 'notes') {
        // Handle Notes quotes search
        await showNotesMenu();
    } else if (selection.type === 'categories') {
        // Handle other categories
        await showCategoriesMenu();
    } else if (selection.type === 'source') {
        // Handle quotes by source
        await showSourceQuotesMenu(selection.source);
    }
}

// Function to show all quotes menu
async function showAllQuotesMenu() {
    const allQuotes = await getAllQuotes();
    
    const selectedQuote = await tp.system.suggester(
        item => formatQuoteForMenu(item.content, item.author, item.source),
        allQuotes,
        false,
        "Search all quotes"
    );
    
    if (selectedQuote) {
        await insertQuote(selectedQuote.content, selectedQuote.source, selectedQuote.file);
        new Notice("Quote inserted successfully");
    } else {
        // If ESC was pressed, go back to main menu
        await showMainMenu();
    }
}

// Function to show author selection menu
async function showAuthorMenu() {
    const authors = await getAllAuthors();
    if (authors.length === 0) {
        new Notice("No authors found");
        await showMainMenu();
        return;
    }
    
    const selectedAuthor = await tp.system.suggester(
        author => author,
        authors,
        false,
        "Select author"
    );
    
    if (!selectedAuthor) {
        // If ESC was pressed, go back to main menu
        await showMainMenu();
        return;
    }
    
    // Get all quotes and filter by the selected author
    const allQuotes = await getAllQuotes();
    const authorQuotes = allQuotes.filter(quote => {
        if (Array.isArray(quote.author)) {
            return quote.author.some(author => formatAuthorDisplay(author) === selectedAuthor);
        } else {
            return formatAuthorDisplay(quote.author) === selectedAuthor;
        }
    });
    
    if (authorQuotes.length === 0) {
        new Notice(`No quotes found for author: ${selectedAuthor}`);
        await showAuthorMenu(); // Go back to author selection
        return;
    }
    
    const selectedQuote = await tp.system.suggester(
        item => formatQuoteForMenu(item.content, item.author, item.source),
        authorQuotes,
        false,
        `Quotes by ${selectedAuthor}`
    );
    
    if (selectedQuote) {
        await insertQuote(selectedQuote.content, selectedQuote.source, selectedQuote.file);
        new Notice("Quote inserted successfully");
    } else {
        // If ESC was pressed, go back to author selection
        await showAuthorMenu();
    }
}

// Function to show KOI quotes menu
async function showKOIMenu() {
    const koiQuotes = await getKOIQuotes();
    
    if (koiQuotes.length === 0) {
        new Notice("No KOI quotes found");
        await showMainMenu();
        return;
    }
    
    // Modified: Hide source for KOI quotes
    const selectedQuote = await tp.system.suggester(
        item => formatQuoteForMenu(item.content, item.author, item.source, true), // Set hideSource to true
        koiQuotes,
        false,
        "KOI Quotes (newest first)"
    );
    
    if (selectedQuote) {
        await insertQuote(
            selectedQuote.content, 
            selectedQuote.source, 
            selectedQuote.file, 
            true, // Set isKOI to true
            {   // Pass metadata for author_name and channel_name
                author_name: selectedQuote.author_name || formatAuthorDisplay(selectedQuote.author),
                channel_name: selectedQuote.channel_name || "Unknown channel"
            }
        );
        new Notice("KOI quote inserted successfully");
    } else {
        // If ESC was pressed, go back to main menu
        await showMainMenu();
    }
}

// NEW: Function to show Notes quotes menu
async function showNotesMenu() {
    const notesQuotes = await getNotesQuotes();
    
    if (notesQuotes.length === 0) {
        new Notice("No Notes quotes found");
        await showMainMenu();
        return;
    }
    
    const selectedQuote = await tp.system.suggester(
        item => formatQuoteForMenu(item.content, item.author, item.source),
        notesQuotes,
        false,
        "Notes Quotes (newest first)"
    );
    
    if (selectedQuote) {
        await insertQuote(selectedQuote.content, selectedQuote.source, selectedQuote.file);
        new Notice("Notes quote inserted successfully");
    } else {
        // If ESC was pressed, go back to main menu
        await showMainMenu();
    }
}

// NEW: Function to show categories menu
async function showCategoriesMenu() {
    const categories = await getAllCategories();
    
    if (categories.length === 0) {
        new Notice("No other categories found");
        await showMainMenu();
        return;
    }
    
    const selectedCategory = await tp.system.suggester(
        category => category,
        categories,
        false,
        "Select category"
    );
    
    if (!selectedCategory) {
        // If ESC was pressed, go back to main menu
        await showMainMenu();
        return;
    }
    
    // Show quotes for the selected category
    await showCategoryQuotesMenu(selectedCategory);
}

// NEW: Function to show quotes for a specific category
async function showCategoryQuotesMenu(selectedCategory) {
    const categoryQuotes = await getQuotesByCategory(selectedCategory);
    
    if (categoryQuotes.length === 0) {
        new Notice(`No quotes found for category: ${selectedCategory}`);
        await showCategoriesMenu(); // Go back to category selection
        return;
    }
    
    const selectedQuote = await tp.system.suggester(
        item => formatQuoteForMenu(item.content, item.author, item.source),
        categoryQuotes,
        false,
        `Quotes from ${selectedCategory}`
    );
    
    if (selectedQuote) {
        await insertQuote(selectedQuote.content, selectedQuote.source, selectedQuote.file);
        new Notice(`${selectedCategory} quote inserted successfully`);
    } else {
        // If ESC was pressed, go back to category selection
        await showCategoriesMenu();
    }
}

// Function to show quotes by source
async function showSourceQuotesMenu(selectedSource) {
    const allQuotes = await getAllQuotes();
    
    // Filter quotes by the selected source, excluding KOI quotes
    const sourceQuotes = allQuotes.filter(quote => {
        try {
            return formatSourceDisplay(quote.source) === selectedSource &&
                !(quote.class === 'Quotes' && quote.category === 'KOI');
        } catch (error) {
            console.error("Error in source filtering:", error);
            return false;
        }
    });
    
    if (sourceQuotes.length === 0) {
        new Notice(`No quotes found for source: ${selectedSource}`);
        await showMainMenu();
        return;
    }
    
    const selectedQuote = await tp.system.suggester(
        item => formatQuoteForMenu(item.content, item.author, item.source),
        sourceQuotes,
        false,
        `Quotes from ${selectedSource}`
    );
    
    if (selectedQuote) {
        await insertQuote(selectedQuote.content, selectedQuote.source, selectedQuote.file);
        new Notice("Quote inserted successfully");
    } else {
        // If ESC was pressed, go back to main menu
        await showMainMenu();
    }
}

// Run the main function
await selectAndInsertQuote();
-%>