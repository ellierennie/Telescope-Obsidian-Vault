<%*
const templateType = "create";
const description = "add custom sources (transcripts, screenshots etc";

// Configuration
const DESTINATION_FOLDER = "Inputs";  
const NEW_NOTE = "_system/Templates/_Primary/_Input.md";
const NEW_NOTE_PROMPT = "📍 Title Custom Input";

// Initial validation
function validateLocation() {
    const currentFile = tp.file.folder(true);
    const selectedText = tp.file.selection();
    
    // You can customize this condition if needed
    if (currentFile.startsWith("_system/Templates")) {
        new Notice("Can't run template here");
        // Re-paste the selected text
        const editor = app.workspace.activeEditor?.editor;
        if (editor && selectedText) {
            editor.replaceSelection(selectedText);
        }
        return { valid: false, selectedText };
    }
    return { valid: true, selectedText };
}

// Helper Functions
const formatTitle = (title) => title.trim().replace(/\.$/, '');

// Create new note function
async function createNewNote(name, folder, template = NEW_NOTE, wasSelectedText = false) {
    try {
        // Create the destination folder if it doesn't exist
        if (!app.vault.getAbstractFileByPath(folder)) {
            await app.vault.createFolder(folder);
        }

        const templateFile = tp.file.find_tfile(template);
        if (!templateFile) {
            throw new Error(`Template file not found: ${template}`);
        }

        const title = formatTitle(name);
        const newFilePath = `${folder}/${title}.md`;
        await app.vault.create(newFilePath, await app.vault.read(templateFile));

        const newFile = app.vault.getAbstractFileByPath(newFilePath);
        if (!newFile) {
            throw new Error("Failed to create new file");
        }

        // Process template variables
        const vars = {
            title: title,
            class: "Note", // Default class, could be modified if needed
        };

        let fileContent = await app.vault.read(newFile);
        Object.keys(vars).forEach(key => {
            const regex = new RegExp(`{{${key}}}`, 'g');
            fileContent = fileContent.replace(regex, vars[key]);
        });
        await app.vault.modify(newFile, fileContent);

        // Handle selected text case
        if (wasSelectedText) {
            const activeLeaf = app.workspace.activeLeaf;
            await app.workspace.openLinkText(newFile.path, '', true);
            await app.workspace.setActiveLeaf(activeLeaf);
            return { file: newFile, wikilink: `[[${newFile.basename}]]` };
        } else {
            // Open the new note
            await app.workspace.openLinkText(newFile.path, '', true);
            return { file: newFile };
        }
    } catch (error) {
        console.error("Error in createNewNote:", error);
        throw error;
    }
}

// Main function
async function main() {
    const validation = validateLocation();
    if (!validation.valid) {
        return '';  // The text has already been re-pasted in validateLocation
    }

    try {
        // Check if there's selected text
        const selectedText = tp.file.selection();
        
        if (selectedText) {
            // Create note with selected text as title
            const result = await createNewNote(selectedText, DESTINATION_FOLDER, NEW_NOTE, true);
            return result.wikilink;
        } else {
            // Prompt for note title
            const title = await tp.system.prompt(NEW_NOTE_PROMPT);
            if (!title?.trim()) return '';
            
            // Create note with provided title
            await createNewNote(title, DESTINATION_FOLDER, NEW_NOTE, false);
            return '';
        }
    } catch (error) {
        console.error("Error in main function:", error);
        new Notice(`Error: ${error.message}`);
        // If there was an error, re-paste any selected text
        const editor = app.workspace.activeEditor?.editor;
        if (editor && validation.selectedText) {
            editor.replaceSelection(validation.selectedText);
        }
        return '';
    }
}

// Run the main function and set the result
tR += await main();
%>