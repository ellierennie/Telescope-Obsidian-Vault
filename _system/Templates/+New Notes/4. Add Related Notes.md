<%*
const templateType = "create";

// Configuration
const CONFIG = {
    fieldName: "relatedNotes",
    includeFolder: "",
    excludeFolder: "_system",
    class: "Notes",
    type: "",
    active: null,
};

// Get Dataview plugin
const dv = this.app.plugins.plugins["dataview"].api;

// Simplified functions for wiki link handling
function getDisplayName(filename) {
    // Get clean display name for UI
    return filename.replace(/\.md$/, '');
}

function toWikiLink(name) {
    // Convert name to proper wiki link format
    return `[[${name}]]`;
}

function fromWikiLink(link) {
    // Extract name from wiki link
    if (!link || typeof link !== 'string') return '';
    
    // Remove [[ and ]]
    let name = link.replace(/^\[\[|\]\]$/g, '');
    
    // Handle aliases (take part before |)
    if (name.includes('|')) {
        name = name.split('|')[0];
    }
    
    return name.trim();
}

function compareNames(name1, name2) {
    // Compare names ignoring file extension, path, etc.
    const clean1 = fromWikiLink(name1).split('/').pop().replace(/\.md$/, '');
    const clean2 = fromWikiLink(name2).split('/').pop().replace(/\.md$/, '');
    return clean1.toLowerCase() === clean2.toLowerCase();
}

try {
    // Get current file
    const file = tp.file.find_tfile(tp.file.title);
    if (!file) {
        new Notice("Could not find current file.");
        return;
    }
    
    // STEP 1: Get all potential related notes
    const pages = dv.pages()
        .where(p => !p.file.path.includes(CONFIG.excludeFolder))
        .where(p => p.class === CONFIG.class || !CONFIG.class)
        .where(p => p.file.name !== file.basename); // Exclude current file
    
    // STEP 2: Create structured array of items with types
    const allNotes = [];
    for (let page of pages.values) {
        // Get the type, default to "note" if not specified
        let type = page.type ? String(page.type).toLowerCase() : "note";
        
        // Get display name
        let displayName = getDisplayName(page.file.name);
        
        // Add to list with all needed info
        allNotes.push({
            path: page.file.path,
            name: page.file.name,
            displayName: displayName,
            wikiLink: toWikiLink(displayName),
            type: type
        });
    }
    
    // STEP 3: Sort items (MOCs at top, then alphabetical)
    allNotes.sort((a, b) => {
        if (a.type === "moc" && b.type !== "moc") return -1;
        if (a.type !== "moc" && b.type === "moc") return 1;
        return a.displayName.localeCompare(b.displayName);
    });
    
    // STEP 4: Get current related notes using reliable methods
    let currentRelated = [];
    try {
        // Try metadata cache first
        const metaCache = app.metadataCache.getCache(file.path);
        if (metaCache && metaCache.frontmatter && metaCache.frontmatter[CONFIG.fieldName]) {
            const relatedFromMeta = metaCache.frontmatter[CONFIG.fieldName];
            currentRelated = Array.isArray(relatedFromMeta) ? relatedFromMeta : [relatedFromMeta];
        } else {
            // Fall back to dataview if needed
            const dvPage = dv.page(file.path);
            const relatedFromDV = dvPage[CONFIG.fieldName];
            if (relatedFromDV) {
                currentRelated = Array.isArray(relatedFromDV) ? relatedFromDV : [relatedFromDV];
            }
        }
    } catch (e) {
        new Notice(`Error reading frontmatter: ${e.message}`);
    }
    
    // STEP 5: Build the selection dialog
    let isEditingItems = true;
    
    // Add "Clear Field" option at the top
    const CLEAR_OPTION = "🗑️ Clear All";
    
    while (isEditingItems) {
        // Build display options array with emoji prefixes
        const displayOptions = [CLEAR_OPTION]; // Add clear option as first item
        const valueOptions = [CLEAR_OPTION];   // Same value for clear option
        
        for (const note of allNotes) {
            // Get emoji prefix based on type
            let emoji = "";
            if (note.type === "moc") {
                emoji = "🗺️ ";
            } else if (note.type === "note") {
                emoji = "🗒️";
            }
            
            // Check if this item is already selected
            // Compare with the actual name, not the link format
            const isSelected = currentRelated.some(rel => 
                compareNames(rel, note.displayName)
            );
            
            const checkmark = isSelected ? "✓ " : "";
            
            // Add to display and value arrays
            displayOptions.push(`${checkmark}${emoji}${note.displayName}`);
            valueOptions.push(note.displayName);
        }
        
        // Show the suggester dialog
        const selectedItem = await tp.system.suggester(
            displayOptions,
            valueOptions,
            false,
            `Select items for ${CONFIG.fieldName} (ESC when done)`
        );
        
        if (selectedItem === CLEAR_OPTION) {
            // User selected the clear option
            currentRelated = [];
            new Notice(`Cleared all items from ${CONFIG.fieldName}`);
            isEditingItems = false; // Exit the loop after clearing
        } else if (selectedItem) {
            // Find the exact wiki link format
            const wikiLinkFormat = toWikiLink(selectedItem);
            
            // Check if it's already in current selections
            const existingIndex = currentRelated.findIndex(rel => 
                compareNames(rel, selectedItem)
            );
            
            if (existingIndex >= 0) {
                // If found, remove it (toggle off)
                currentRelated.splice(existingIndex, 1);
            } else {
                // If not found, add it (toggle on)
                currentRelated.push(wikiLinkFormat);
            }
        } else {
            // User pressed ESC
            isEditingItems = false;
        }
    }
    
    // STEP 6: Update frontmatter
    try {
        // Filter out any empty items
        const validItems = currentRelated.filter(item => 
            item && fromWikiLink(item).trim() !== ''
        );
        
        if (validItems.length > 0) {
            // Update YAML frontmatter
            await app.fileManager.processFrontMatter(file, (frontmatter) => {
                // Use array for multiple items, single value for one item
                frontmatter[CONFIG.fieldName] = validItems.length === 1 ? validItems[0] : validItems;
            });
            
            // Notify user of update
            new Notice(`Updated ${CONFIG.fieldName} with ${validItems.length} item(s)`);
        } else {
            // If no items selected, remove the field
            await app.fileManager.processFrontMatter(file, (frontmatter) => {
                if (CONFIG.fieldName in frontmatter) {
                    delete frontmatter[CONFIG.fieldName];
                    new Notice(`Removed ${CONFIG.fieldName} field as no items were selected`);
                } 
            });
        }
    } catch (e) {
        new Notice(`Error updating frontmatter: ${e.message}`);
    }
} catch (e) {
    new Notice(`Error in template: ${e.message}`);
}
-%>