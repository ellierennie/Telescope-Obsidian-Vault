<%*
// Configuration
const CLASS_NAME = "Sources";
const CLASS_EMOJI = "📚";
const AUTHOR_EMOJI = "👤";
const CATEGORY_EMOJI = "📂";
const SEARCH_EMOJI = "🔍";
const MENU_TITLE = `${CLASS_EMOJI} Open Sources`;  // Changed from "Sources" to "Open Sources"

// Stop conditions
const EXCLUDE_PATH = "_system/Templates";

// Initial validation
function validateLocation() {
    const currentFile = tp.file.folder(true);
    if (currentFile.startsWith(EXCLUDE_PATH)) {
        new Notice("Can't run template here");
        return false;
    }
    return true;
}

// Function to extract author name from link format
function extractAuthorName(authorLink) {
    if (!authorLink) return '';
    
    // Check if it's a wiki link format with pipe
    const wikiLinkMatch = authorLink.match(/\[\[(?:.*?\|)([^\]]+?)(?:\.md)?\]\]/);
    if (wikiLinkMatch) {
        return wikiLinkMatch[1];
    }
    
    // Check if it's a simple wiki link format
    const simpleLinkMatch = authorLink.match(/\[\[([^\]]+?)(?:\.md)?\]\]/);
    if (simpleLinkMatch) {
        return simpleLinkMatch[1];
    }
    
    // Remove quotes if present
    return authorLink.replace(/"/g, '').trim();
}

// Function to extract all authors from a source
function extractAuthors(authorField) {
    if (!authorField) return [];
    
    // Handle array of authors
    if (Array.isArray(authorField)) {
        return authorField
            .map(author => extractAuthorName(author.toString()))
            .filter(author => author); // Remove empty entries
    }
    
    // Handle single string that might contain multiple authors
    const authorStr = authorField.toString();
    
    // Check if it contains multiple wiki links
    if (authorStr.includes('[[') && authorStr.split('[[').length > 2) {
        const matches = [...authorStr.matchAll(/\[\[(?:.*?\|)?([^\]]+?)(?:\.md)?\]\]/g)];
        if (matches.length > 0) {
            return matches.map(match => match[1]).filter(author => author);
        }
    }
    
    // Handle comma-separated string of authors
    if (authorStr.includes(',')) {
        return authorStr
            .split(',')
            .map(author => extractAuthorName(author.trim()))
            .filter(author => author);
    }
    
    // Single author
    const singleAuthor = extractAuthorName(authorStr);
    return singleAuthor ? [singleAuthor] : [];
}

// Function to process categories
function processCategories(categoryField) {
    if (!categoryField) return [];
    
    // Handle array of categories
    if (Array.isArray(categoryField)) {
        return categoryField
            .map(cat => cat.toString().trim())
            .filter(cat => cat);
    }
    
    // Handle comma-separated string
    const categoryStr = categoryField.toString();
    if (categoryStr.includes(',')) {
        return categoryStr
            .split(',')
            .map(cat => cat.trim())
            .filter(cat => cat);
    }
    
    // Single category
    return [categoryStr.trim()];
}

// Function to format authors for display
function formatAuthorsForDisplay(authors) {
    if (!authors || authors.length === 0) return 'Unknown Author';
    return authors.join(', ');
}

// Check if file should be excluded
function shouldExcludeFile(filePath) {
    return filePath.includes(EXCLUDE_PATH);
}

// Open the selected file in Obsidian
function openFile(file) {
    // Check if file exists
    if (file) {
        // Open the file in the current workspace
        app.workspace.openLinkText(file.path, '', false);
        return true;
    }
    return false;
}

// Get all sources and build maps
const getSourceData = () => {
    let sources = [];
    let authorMap = new Map(); // Maps author names to lists of sources
    let categoryMap = new Map(); // Maps categories to lists of sources
    
    const files = app.vault.getMarkdownFiles();
    
    files.forEach(file => {
        try {
            if (shouldExcludeFile(file.path)) return;
            
            const page = app.plugins.plugins.dataview.api.page(file.path);
            if (page.class && 
                page.class.toString().toLowerCase() === CLASS_NAME.toLowerCase()) {
                
                // Extract authors (excluding items from excluded path)
                const authorList = page.author ? extractAuthors(page.author) : [];
                
                // Extract categories
                const categoryList = page.category ? processCategories(page.category) : [];
                
                // Create source object
                const source = {
                    name: file.name.replace(/\.md$/, ''),
                    path: file.path,
                    file: file,
                    isFlagged: page.flag === true,
                    title: page.title ? page.title.toString() : '',
                    authors: authorList,
                    categories: categoryList
                };
                
                // Add to sources list
                sources.push(source);
                
                // Add to author map
                authorList.forEach(author => {
                    if (!authorMap.has(author)) {
                        authorMap.set(author, []);
                    }
                    authorMap.get(author).push(source);
                });
                
                // Add to category map
                categoryList.forEach(category => {
                    if (!categoryMap.has(category)) {
                        categoryMap.set(category, []);
                    }
                    categoryMap.get(category).push(source);
                });
            }
        } catch (e) {
            // Skip if file doesn't have required metadata
        }
    });
    
    // Sort sources - flagged first, then alphabetically
    sources.sort((a, b) => {
        if (a.isFlagged && !b.isFlagged) return -1;
        if (!a.isFlagged && b.isFlagged) return 1;
        return a.name.localeCompare(b.name);
    });
    
    return { sources, authorMap, categoryMap };
};

// Format source for display
const formatSourceForDisplay = (source) => {
    const lines = [
        `${source.isFlagged ? '🏷️ ' : ''}${source.name}`
    ];
    
    if (source.title) {
        lines.push(`Title: ${source.title}`);
    }
    
    lines.push(`Author: ${formatAuthorsForDisplay(source.authors)}`);
    
    if (source.categories && source.categories.length > 0) {
        lines.push(`Category: ${source.categories.join(', ')}`);
    }
    
    return lines.join('\n');
};

// Function to display the author selection menu
async function showAuthorMenu(authorMap) {
    // Create sorted list of authors with source counts
    const authors = Array.from(authorMap.entries())
        .sort((a, b) => {
            // Sort by number of sources (descending) then by name (ascending)
            if (b[1].length !== a[1].length) {
                return b[1].length - a[1].length;
            }
            return a[0].localeCompare(b[0]);
        })
        .map(([author, authorSources]) => ({ 
            name: `${AUTHOR_EMOJI} ${author} (${authorSources.length})`,
            author: author,
            count: authorSources.length
        }));
    
    // Show author selection
    const authorSelection = await tp.system.suggester(
        item => item.name,
        authors,
        false,
        `${SEARCH_EMOJI} Select Author`
    );
    
    // ESC pressed in author selection - return null to go back
    if (!authorSelection) {
        return null;
    }
    
    // Get sources for selected author
    const authorSources = authorMap.get(authorSelection.author) || [];
    
    // Show sources by selected author
    const sourceSelection = await tp.system.suggester(
        source => formatSourceForDisplay(source),
        authorSources,
        false,
        `${AUTHOR_EMOJI} Sources by ${authorSelection.author} (${authorSources.length})`
    );
    
    // ESC pressed in filtered view - return back signal
    if (!sourceSelection) {
        return { goBack: true };
    }
    
    // Return the selected source
    return { source: sourceSelection };
}

// Function to display the category selection menu
async function showCategoryMenu(categoryMap) {
    // Create sorted list of categories with source counts
    const categories = Array.from(categoryMap.entries())
        .sort((a, b) => {
            // Sort by number of sources (descending) then by name (ascending)
            if (b[1].length !== a[1].length) {
                return b[1].length - a[1].length;
            }
            return a[0].localeCompare(b[0]);
        })
        .map(([category, categorySources]) => ({ 
            name: `${CATEGORY_EMOJI} ${category} (${categorySources.length})`,
            category: category,
            count: categorySources.length
        }));
    
    // Show category selection
    const categorySelection = await tp.system.suggester(
        item => item.name,
        categories,
        false,
        `${SEARCH_EMOJI} Select Category`
    );
    
    // ESC pressed in category selection - return null to go back
    if (!categorySelection) {
        return null;
    }
    
    // Get sources for selected category
    const categorySources = categoryMap.get(categorySelection.category) || [];
    
    // Show sources by selected category
    const sourceSelection = await tp.system.suggester(
        source => formatSourceForDisplay(source),
        categorySources,
        false,
        `${CATEGORY_EMOJI} Sources in ${categorySelection.category} (${categorySources.length})`
    );
    
    // ESC pressed in filtered view - return back signal
    if (!sourceSelection) {
        return { goBack: true };
    }
    
    // Return the selected source
    return { source: sourceSelection };
}

// Main function
async function main() {
    if (!validateLocation()) {
        return '';
    }
    
    try {
        // Get all data
        const { sources, authorMap, categoryMap } = getSourceData();
        
        // Main navigation loop
        while (true) {
            // Build menu with search options at the top
            const menuOptions = [
                // Search by author option
                {
                    name: `${AUTHOR_EMOJI} Search by Author`,
                    action: "authorSearch"
                },
                
                // Search by category option
                {
                    name: `${CATEGORY_EMOJI} Search by Category`,
                    action: "categorySearch"
                },
                
                // All sources
                ...sources.map(source => ({
                    name: formatSourceForDisplay(source),
                    action: "select",
                    source: source
                }))
            ];
            
            const selection = await tp.system.suggester(
                item => item.name,
                menuOptions,
                false,
                MENU_TITLE
            );
            
            // ESC pressed in main menu - exit script
            if (!selection) {
                return '';
            }
            
            if (selection.action === "authorSearch") {
                // Show author menu loop
                while (true) {
                    const result = await showAuthorMenu(authorMap);
                    
                    // Null result means ESC was pressed on first author menu - go back to main
                    if (result === null) {
                        break;
                    }
                    
                    // goBack means ESC was pressed on filtered view - show author menu again
                    if (result.goBack) {
                        continue;
                    }
                    
                    // We have a source selection - open the file
                    if (result.source) {
                        openFile(result.source.file);
                        return '';
                    }
                }
            } else if (selection.action === "categorySearch") {
                // Show category menu loop
                while (true) {
                    const result = await showCategoryMenu(categoryMap);
                    
                    // Null result means ESC was pressed on first category menu - go back to main
                    if (result === null) {
                        break;
                    }
                    
                    // goBack means ESC was pressed on filtered view - show category menu again
                    if (result.goBack) {
                        continue;
                    }
                    
                    // We have a source selection - open the file
                    if (result.source) {
                        openFile(result.source.file);
                        return '';
                    }
                }
            } else if (selection.action === "select") {
                // Open the selected file directly
                openFile(selection.source.file);
                return '';
            }
        }
        
    } catch (error) {
        console.error("Error in main function:", error);
        new Notice(`Error: ${error.message}`);
        return '';
    }
}

// Run the main function without setting template result
await main();
%>