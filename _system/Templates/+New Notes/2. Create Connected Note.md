<%*
// Child Note Creation
const templateType = "create";

// Get active file and editor state immediately
const sourceFile = app.workspace.getActiveFile();
const sourceLeaf = app.workspace.activeLeaf;
const editor = sourceLeaf?.view?.editor;
const cursor = editor?.getCursor();
const selectedText = editor?.getSelection() || tp.file.selection();

// Initialize metadata inheritance
await tp.user.metaInherit(tp);

// Configuration
const DESTINATION_FOLDER = "Notes";
const NEW_NOTE_PROMPT = "ðŸ“ Title new note";

// Helper Functions
const formatTitle = (title) => title.trim().replace(/\.$/, '');

// Main function
async function createChildNote() {
    try {
        // Get title from selection or prompt
        let title;
        if (selectedText && selectedText.trim()) {
            title = formatTitle(selectedText);
        } else {
            title = await tp.system.prompt(NEW_NOTE_PROMPT);
            if (!title?.trim()) {
                throw new Error("No title provided");
            }
            title = formatTitle(title);
        }
        
        // Create folder if it doesn't exist
        if (!app.vault.getAbstractFileByPath(DESTINATION_FOLDER)) {
            await app.vault.createFolder(DESTINATION_FOLDER);
        }
        
        // Create the new file
        const newFilePath = `${DESTINATION_FOLDER}/${title}.md`;
        
        // Get parent file reference and title
        const parentFile = sourceFile;
        const parentTitle = parentFile.basename;
        
        // Set parent as the only related note
        const parentRelatedNotes = `- "[[${parentTitle}]]"`;
        
        // Get current date in YY.MM.DD format
        const currentDate = moment().format('YY.MM.DD');
        
        // Create content with embedded template
        const newContent = `---
class: Notes
type: note
category: ${DESTINATION_FOLDER}
created: ${currentDate}
tags: 
- "${title.replace(/[ ,\.;:'!?]/g, "_")}"
note: 
status: New
source: "[[${parentTitle}]]"
relatedNotes: 
${parentRelatedNotes}
noteAuthor: "${await tp.user.vaultAuthor(tp)}"
---
## See [[${title}#Connected Notes & Quotes|Connected Notes & Quotes]]
\`\`\`dataview 
TABLE WITHOUT ID this.relatedNotes AS "Related Notes", class AS Class
WHERE file.path = this.file.path
\`\`\`

# Notes 
























# Connected Notes & Quotes

\`\`\`dataviewjs
dv.view("mentions", {
  fields: ["note"],
  excludeClass: ["Telescopes"],
  excludeCategory: ["Quotes"]
})
\`\`\`
## Quotes 
\`\`\`dataviewjs
dv.view("displayQuotes")
\`\`\`
`;
        
        // Create the new file
        await app.vault.create(newFilePath, newContent);
        
        // Get the new file reference
        const newFile = app.vault.getAbstractFileByPath(newFilePath);
        if (!newFile) {
            throw new Error("Failed to create new file");
        }
        
        // Update parent with child link
        if (parentFile) {
            // Using a simple string for the child link
            const childLink = `- "[[${title}]]"`;
            const parentContent = await app.vault.read(parentFile);
            
            // Handle updating the parent's relatedNotes
            if (parentContent.includes("relatedNotes:")) {
                // Split content into lines for precise handling
                let lines = parentContent.split('\n');  // Changed from const to let
                let inRelatedNotes = false;
                let relatedNotesLineIndex = -1;
                let lastRelatedNoteLineIndex = -1;
                let emptyRelatedNotes = false;
                
                // Find the relatedNotes section and its last item
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i].trim();
                    
                    if (line.startsWith('relatedNotes:')) {
                        inRelatedNotes = true;
                        relatedNotesLineIndex = i;
                        
                        // Check if relatedNotes is followed by [] on the same line
                        if (line.includes('relatedNotes: []')) {
                            emptyRelatedNotes = true;
                            // Replace the line with just 'relatedNotes:'
                            lines[i] = line.replace('relatedNotes: []', 'relatedNotes:');
                        }
                    } else if (inRelatedNotes) {
                        // Check if next line contains [] (common cleared field pattern)
                        if (line === '[]') {
                            emptyRelatedNotes = true;
                            // Mark this line for removal (we'll handle it below)
                            lines[i] = '!REMOVE_THIS_LINE!';
                        } else if (line.startsWith('- ')) {
                            lastRelatedNoteLineIndex = i;
                        } else if (line.match(/^\w+:/) || line === '---') {
                            // We've hit another field or the end of frontmatter
                            break;
                        }
                    }
                }
                
                // Remove any lines marked for removal
                lines = lines.filter(line => line !== '!REMOVE_THIS_LINE!');
                
                // Skip if the child is already in the list
                if (!parentContent.includes(`[[${title}]]`)) {
                    if (lastRelatedNoteLineIndex >= 0) {
                        // Insert after the last list item, ensuring proper indentation
                        const lastLine = lines[lastRelatedNoteLineIndex];
                        const indentation = lastLine.match(/^(\s*)/)[0];
                        lines.splice(lastRelatedNoteLineIndex + 1, 0, `${indentation}${childLink}`);
                    } else if (relatedNotesLineIndex >= 0) {
                        // Field exists but is empty or was cleared
                        if (emptyRelatedNotes) {
                            // Add as first item with proper indentation after the cleaned relatedNotes field
                            lines.splice(relatedNotesLineIndex + 1, 0, `  ${childLink}`);
                        } else {
                            // Normal case - just add the first item
                            const nextLine = (relatedNotesLineIndex + 1 < lines.length) ? lines[relatedNotesLineIndex + 1] : "";
                            if (nextLine.trim() === "" || nextLine.match(/^\w+:/) || nextLine === '---') {
                                // relatedNotes is empty, add new item with proper indentation
                                lines.splice(relatedNotesLineIndex + 1, 0, `  ${childLink}`);
                            } else {
                                // There's something unexpected after relatedNotes
                                lines.splice(relatedNotesLineIndex + 1, 0, `  ${childLink}`);
                            }
                        }
                    }
                    
                    await app.vault.modify(parentFile, lines.join('\n'));
                }
            } else {
                // If relatedNotes doesn't exist, add it to the frontmatter
                const yamlRegex = /---\n([\s\S]*?)\n---/;
                const match = parentContent.match(yamlRegex);
                
                if (match && match[1]) {
                    const updatedYaml = match[1] + '\nrelatedNotes: \n  ' + childLink;
                    const newContent = parentContent.replace(match[1], updatedYaml);
                    await app.vault.modify(parentFile, newContent);
                }
            }
        }
        
        // Open the new file
        await app.workspace.openLinkText(newFilePath, '', true);
        
        // If we used selected text, return the wikilink
        if (selectedText && selectedText.trim()) {
            return `[[${title}]]`;
        } else {
            return '';
        }
        
    } catch (error) {
        console.error("Error creating child note:", error);
        new Notice(`Error: ${error.message}`);
        
        // If there was an error and we had selected text, restore it
        if (editor && selectedText && selectedText.trim()) {
            editor.replaceSelection(selectedText);
        }
        
        return '';
    }
}

// Run the main function
tR += await createChildNote();


%>