<%*
// QUOTE CAPTURE
const templateType = "create";
const description = "using selected text";

// Get active file and editor state immediately
const sourceFile = app.workspace.getActiveFile();
const sourceLeaf = app.workspace.activeLeaf;
const editor = sourceLeaf.view.editor;
const cursor = editor.getCursor();
const selectedText = editor.getSelection();
// Initialize metadata inheritance
await tp.user.metaInherit(tp);
// Configuration
const QUOTES_FOLDER = "Synthesis/Quotes";

// Improved function to create a sanitised title from selected text
function createTitle(selectedText) {
    let title = selectedText.slice(0, 90).trim().replace(/[\r\n]+/g, " ");
    
    const charMap = {
        ':': '-', '/': '-', '\\': '-', '|': '-', '*': '', '?': '',
        '"': "'", '<': '(', '>': ')', '~': '-', '#': '', '%': '',
        '&': 'and', '{': '(', '}': ')', '^': '', '=': '-', '`': "'"
    };
    
    title = title.replace(/[:/\\|*?"<>~#%&{}^=`]/g, char => charMap[char] || '');
    title = title.trim();
    if (title.length === 90) {
        title += "...";
    }
    return title;
}

// Function to sanitize author name for filename
function sanitizeAuthorForFilename(author) {
    if (!author) return "Unknown";
    
    // Extract name from wiki link format if present
    const match = author.match(/\[\[.*?\|(.*?)\]\]/) || author.match(/\[\[(.*?)\]\]/);
    let authorName = match ? match[1].replace(/"/g, '') : author.replace(/"/g, '');
    
    // Further sanitize the author name for use in filename
    authorName = authorName.replace(/[:/\\|*?"<>~#%&{}^=`]/g, '');
    return authorName.trim().replace(/\s+/g, '_');
}

// Function to only include field if it exists in source
function includeIfExists(fieldName, defaultValue = '') {
    const value = getValue(fieldName);
    return value ? `${fieldName}: ${value}` : '';
}

// Main function
async function createQuoteNote() {
    try {
        if (!selectedText) {
            throw new Error("No text selected");
        }
        
        const sourceTitle = sourceFile.basename;
        const sourceValue = getValue('source') || `"[[${sourceTitle}]]"`;
        const titleForContent = createTitle(selectedText);
        const authorValue = getValue('author') || ` ${getValue('noteAuthor')}`;
        const sanitizedAuthor = sanitizeAuthorForFilename(authorValue);
        const currentClass = getValue('class') || 'Uncategorized';
        
        // Create the new filename with the YYMMDDHHMM_{author}_{title} format
        const timestamp = moment().format('YYMMDDHHMM');
        const shortTitle = createTitle(selectedText).slice(0, 40).replace(/\s+/g, '_');
        const newFilename = `${timestamp}_${sanitizedAuthor}_${shortTitle}`;
        
        // Create subfolder based on class from the metadata
        const folderPath = `${QUOTES_FOLDER}/${currentClass}`;
        if (!app.vault.getAbstractFileByPath(folderPath)) {
            await app.vault.createFolder(folderPath);
        }
        
        // Create the new file with the new naming format
        let newFile = await tp.file.create_new("", newFilename, false, app.vault.getAbstractFileByPath(folderPath));
        if (!newFile) throw new Error("Failed to create new file");
        
        const comment = await tp.system.prompt("Add comment or hit enter");
        
        // Get optional fields only if they exist
        const workspaceField = includeIfExists('workspace');
        const channelField = includeIfExists('channel');
        const authorNameField = includeIfExists('author_name');
        const channelNameField = includeIfExists('channel_name');
        const taggerNameField = includeIfExists('tagger_name');
        const authorIsAnonymousField = includeIfExists('author_is_anonymous');
        
        // Build YAML content with only existing fields
        let yamlContent = `---
type: Synthesis
class: Quotes
category: ${currentClass}
${workspaceField ? workspaceField + '\n' : ''}author: ${authorValue}
${channelField ? channelField + '\n' : ''}source: ${sourceValue}
${authorNameField ? authorNameField :''}
${channelNameField ? channelNameField :''}
created_at: ${getValue('created_at') || ''}
quoteLink: "[[${newFile.basename}|See Quote]]"
quote_created: ${moment().format('YY.MM.DD')}
sourceTitle: ${getValue('title') || sourceTitle}
title: ${titleForContent}
${taggerNameField ? taggerNameField + '\n' : ''}${authorIsAnonymousField ? authorIsAnonymousField + '\n' : ''}emojis: ${getValue('emojis') || ''}
tags: ${getValue('tags') || ''}
comments: ${getValue('comments') || ''}
note: ${comment}
noteAuthor: "${await tp.user.vaultAuthor(tp)}"
---`;
        
        // Full content with YAML frontmatter
        const newContent = `${yamlContent}
${selectedText}

---
## Source: [[${sourceTitle}]]
## Notes










\`\`\`dataviewjs
dv.view("displayQuotesBySource")
\`\`\`
`;
        
        await app.vault.modify(newFile, newContent);
        
        // Open the new note in a new tab without switching focus
        let newLeaf = app.workspace.getLeaf('tab');
        await newLeaf.openFile(newFile, { active: false });
        
        // Ensure focus remains on the source file
        app.workspace.setActiveLeaf(sourceLeaf);
        editor.setCursor(cursor);
        
        new Notice("Quote note created successfully.");
    } catch (error) {
        new Notice(`Error: ${error.message}`);
        console.error(error);
    }
}
// Run the main function
await createQuoteNote();
-%>